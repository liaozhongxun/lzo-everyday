#### 一、从浏览器接收url到开启网络请求线程（这一部分可以展开浏览器的机制以及进程与线程之间的关系）
#####   (1) 浏览器是多进程的，有一个主控进程，以及每一个tab页面都会新开一个进程
#####   (2) 每一个tab页面可以看作是浏览器内核进程(一般包括GUI线程,JS引擎线程,事件触发线程,定时器线程,网络请求线程等多个线程)
#####   (3) 解析URL(协议//主机:端口号/目录路径#查询参数#hash)
#####   (4) 解析协议 : 浏览器会根据解析出的协议，开辟一个网络线程，前往请求资源

####  二、开启网络线程到发出一个完整的http请求（这一部分涉及到dns查询，tcp/ip请求，五层因特网协议栈等知识）
#####   (1) 解析主机 : 如果输入主机的是域名，需要进行dns解析成IP
       1-1、如果浏览器有缓存，直接使用浏览器缓存，否则使用本机缓存，再没有的话就是用host
       1-2、如果本地没有，就向dns域名服务器查询，查询到对应的IP
#####   (2) 连接主机 : tcp/ip请求(三次握手建立连接发送请求,四次挥手断开连接)
       2-1、3次过程
            2-1-1、     
            2-1-2、     
            2-1-3、     
       2-2、4次过程
            2-2-1、
            2-2-2、
            2-2-3、
            2-2-4、

####  三、从服务器接收到请求后的处理（这一部分可能涉及到负载均衡，安全拦截以及后台内部的处理等等）
#####    (1) 负载均衡：对于大型的项目，由于并发访问量很大，所以往往一台服务器是吃不消的，所需要的处理方案称为负载均衡
#####    (2) 一般需要的处理步骤
        2-1、一般有的后端是有统一的验证的，如安全拦截，跨域验证
        2-2、如果这一步不符合规则，就直接返回了相应的http报文（如拒绝请求等）
        2-3、然后当验证通过后，才会进入实际的后台代码，此时是程序接收到请求，然后执行（譬如查询数据库，大量计算等等）
        2-4、等程序执行完毕后，就会返回一个http响应包（一般这一步也会经过多层封装）
        2-5、然后就是将这个包从后端发送到前端，完成交互

####  四、后台和前台的http交互（这一部分包括http头部、响应码、报文结构、cookie等知识，可以提下静态资源的cookie优化，以及编码解码，如gzip压缩等）
#####    (1) http报文(http报文作为信息的载体)
        1-1、通用头部(General)
             1-1-1、Request Url: 请求的web服务器地址
             1-1-1、Request Method: 请求方式（http:1.1 -> Get、POST、OPTIONS、PUT、HEAD、DELETE、CONNECT、TRACEd等）
             1-1-1、Status Code: 请求的返回状态码，如200代表成功
                    1xx——指示信息，表示请求已接收，继续处理
                    2xx——成功，表示请求已被成功接收、理解、接受
                    3xx——重定向，要完成请求必须进行更进一步的操作
                    4xx——客户端错误，请求有语法错误或请求无法实现
                    5xx——服务器端错误，服务器未能实现合法的请求

                    200——表明该请求被成功地完成，所请求的资源发送回客户端
                    304——自从上次请求后，请求的网页未修改过，请客户端使用本地缓存
                    400——客户端请求有错（譬如可以是安全模块拦截）
                    401——请求未经授权
                    403——禁止访问（譬如可以是未登录时禁止）
                    404——资源未找到
                    500——服务器内部错误
                    503——服务不可用
                    .....

             1-1-1、Remote Address: 请求的远程服务器地址

        1-2、请求头(Request headers)
            Accept: 接收类型，表示浏览器支持的MIME类型
            （对标服务端返回的Content-Type）
            Accept-Encoding：浏览器支持的压缩类型,如gzip等,超出类型不能接收
            Content-Type：客户端发送出去实体内容的类型
            Cache-Control: 指定请求和响应遵循的缓存机制，如no-cache
            If-Modified-Since：对应服务端的Last-Modified，用来匹配看文件是否变动，只能精确到1s之内，http1.0中
            Expires：缓存控制，在这个时间内不会请求，直接使用缓存，http1.0，而且是服务端时间
            Max-age：代表资源在本地缓存多少秒，有效时间内不会请求，而是使用缓存，http1.1中
            If-None-Match：对应服务端的ETag，用来匹配文件内容是否改变（非常精确），http1.1中
            Cookie: 有cookie并且同域访问时会自动带上
            Connection: 当浏览器与服务器通信时对于长连接如何进行处理,如keep-alive
            Host：请求的服务器URL
            Origin：最初的请求是从哪里发起的（只会精确到端口）,Origin比Referer更尊重隐私
            Referer：该页面的来源URL(适用于所有类型的请求，会精确到详细页面地址，csrf拦截常用到这个字段)
            User-Agent：用户客户端的一些必要信息，如UA头部等
        1-3、响应头(Response headers)
            Access-Control-Allow-Headers: 服务器端允许的请求Headers
            Access-Control-Allow-Methods: 服务器端允许的请求方法
            Access-Control-Allow-Origin: 服务器端允许的请求Origin头部（譬如为*）
            Content-Type：服务端返回的实体内容的类型
            Date：数据从服务器发送的时间
            Cache-Control：告诉浏览器或其他客户，什么环境可以安全的缓存文档
            Last-Modified：请求资源的最后修改时间
            Expires：应该在什么时候认为文档已经过期,从而不再缓存它
            Max-age：客户端的本地资源应该缓存多少秒，开启了Cache-Control后有效
            ETag：请求变量的实体标签的当前值
            Set-Cookie：设置和页面关联的cookie，服务器通过这个头部把cookie传给客户端
            Keep-Alive：如果客户端有keep-alive，服务端也会有响应（如timeout=38）
            Server：服务器的一些相关信息
        
        譬如，请求头部的Accept要和响应头部的Content-Type匹配，否则会报错
        譬如，跨域请求时，请求头部的Origin要匹配响应头部的Access-Control-Allow-Origin，否则会报跨域错误。。。
        1-4、请求/响应体
#####    (2) cookie 服务器向浏览器写入某些信息
#####    (3) gzip 压缩效率很好（高达70%左右）
#####    (4) 长连接与短连接
        4-1、长连接:一个tcp/ip连接上可以连续发送多个数据包，在tcp连接保持期间，如果没有数据包发送，需要双方发检测包以维持此连接，一般需要自己做在线维持（类似于心跳包）http1.1起，默认使用长连接，使用长连接会有这一行Connection: keep-alive
        
        4-2、短连接:通信双方有数据交互时，就建立一个tcp连接，数据发送完成后，则断开此tcp连接(http1.0默认短连接)
#####    (5) https
* https就是安全版本的http，譬如一些支付等操作基本都是基于https的，因为http请求的安全系数太低了。
* 简单来看，https与http的区别就是： 在请求前，**会建立ssl链接，确保接下来的通信都是加密的**，无法被轻易截取分析
* 一般来说，如果要将网站升级成https，需要后端支持（后端需要申请证书等），然后https的开销也比http要大（因为需要额外建立安全链接以及加密等），所以*一般来说http2.0配合https的体验更佳（因为http2.0更快了）
##### (6) http 2.0
    6-1、http2.0不是https，它相当于是http的下一代规范
    6-2、然后简述下http2.0与http1.1的显著不同点：
            http1.1中，每请求一个资源，都是需要开启一个tcp/ip连接的，所以对应的结果是，每一个资源对应一个tcp/ip请求，由于tcp/ip本身有并发数限制，所以当资源一多，速度就显著慢下来
            http2.0中，一个tcp/ip请求可以请求多个资源，也就是说，只要一次tcp/ip请求，就可以请求若干个资源，分割成更小的帧请求，速度明显提升。
            所以，如果http2.0全面应用，很多http1.1中的优化方案就无需用到了（譬如打包成精灵图，静态资源多域名拆分等）

    6-3、然后简述下http2.0的一些特性：
        多路复用（即一个tcp/ip连接可以请求多个资源）
        首部压缩（http头部压缩，减少体积）
        二进制分帧（在应用层跟传送层之间增加了一个二进制分帧层，改进传输性能，实现低延迟和高吞吐量）
        服务器端推送（服务端可以对客户端的一个请求发出多个响应，可以主动通知客户端）
        请求优先级（如果流被赋予了优先级，它就会基于这个优先级来处理，由服务器决定需要多少资源来处理该请求。）

###### 五、缓存
5-1、强缓存(200 from cache)与弱缓存(304)
* 强缓存（200 from cache）时，浏览器如果判断本地缓存未过期，就直接使用，无需发起http请求
* 协商缓存（304）时，浏览器会向服务端发起http请求，然后服务端告诉浏览器文件未改变，让浏览器使用本地缓存
> 对于协商缓存，使用Ctrl + F5强制刷新可以使得缓存无效
> 但是对于强缓存，在未过期时，必须更新资源路径才能发起新的请求（更改了路径相当于是另一个资源了，这也是前端工程化中常用到的技巧）

5-2、相关头部
> If-None-Match/E-tag、If-Modified-Since/Last-Modified、Cache-Control/Max-Age、Pragma/Expires

http1.0中的缓存控制：
* Pragma
* Expires 用的是服务器时间
* 请求头(浏览器端)If-Modified-Since 与 响应头(服务器端) Last-Modifie 相匹配,说明内容未变(协商缓存)

http1.1中的缓存控制：
* Cache-Control：缓存控制头部，有no-cache、max-age等多种取值
* max-age='xxx'：服务端配置的，用来控制强缓存，在规定的时间之内，浏览器无需发出请求，直接使用本地缓存
* 请求头(浏览器端)If-None-Match 与 响应头(服务器端) E-tag 相匹配,说明内容未变(协商缓存)

E-tag相比Last-Modified？

    Last-Modified：
    表明服务端的文件最后何时改变的
    它有一个缺陷就是只能精确到1s，
    然后还有一个问题就是有的服务端的文件会周期性的改变，导致缓存失效

    E-tag：
    是一种指纹机制，代表文件相关指纹
    只有文件变才会变，也只要文件变就会变，
    也没有精确时间的限制，只要文件一遍，立马E-tag就不一样了

    如果同时带有E-tag和Last-Modified，服务端会优先检查E-tag


#### 六、 浏览器接收到http数据包后的解析流程（解析html-词法分析然后解析成dom树、解析css生成css规则树、合并成render树，然后layout、painting渲染、复合图层的合成、GPU绘制、外链资源的处理、loaded和domcontentloaded等）
##### (1)、 解析HTML，构建DOM树

##### (2)、 解析CSS，生成CSSOM树

##### (3)、 合并DOM树和CSSOM树，生成render树

##### (4)、 布局render树（Layout/reflow），负责各元素尺寸、位置的计算
* Layout 也称为Reflow，即回流,一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树
* Repaint，即重绘。意味着元素发生的改变只是影响了元素的一些外观之类的时候（例如，背景色，边框颜色，文字颜色等），此时只需要应用新样式绘制这个元素就可以了

>回流的成本开销要高于重绘，而且一个节点的回流往往回导致子节点以及同级节点的回流，
所以优化方案中一般都包括，尽量避免回流。

引起重绘的条件

```javascript
// 1.页面渲染初始化

// 2.DOM结构改变，比如删除了某个节点

// 3.render树变化，比如减少了padding

// 4.窗口resize

// 5.最复杂的一种：获取某些属性，引发回流，
// 很多浏览器会对回流做优化，会等到数量足够时做一次批处理回流，
// 但是除了render树的直接变化，当获取一些属性时，浏览器为了获得正确的值也会触发回流，这样使得浏览器优化无效，包括
//     （1）offset(Top/Left/Width/Height)
//      (2) scroll(Top/Left/Width/Height)
//      (3) cilent(Top/Left/Width/Height)
//      (4) width,height
//      (5) 调用了getComputedStyle()或者IE的currentStyle
// 6、改变字体大小会引发回流

//一般dom结构发生变化引发回流加重绘,样色变化只会发生重绘, 回流一定伴随着重绘，重绘却可以单独出现
```

##### (5)、 绘制render树（paint），绘制页面像素信息

##### (6)、 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上



#### 七、 CSS的可视化格式模型（元素的渲染规则，如包含块，控制框，BFC，IFC等概念）

#### 八、 JS引擎解析过程（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等）

#### 九、 其它（可以拓展不同的知识模块，如跨域，web安全，hybrid模式等等内容）
[from](https://segmentfault.com/a/1190000013662126#articleHeader10)