一、从浏览器接收url到开启网络请求线程（这一部分可以展开浏览器的机制以及进程与线程之间的关系）
   (1) 浏览器是多进程的，有一个主控进程，以及每一个tab页面都会新开一个进程
   (2) 每一个tab页面可以看作是浏览器内核进程(一般包括GUI线程,JS引擎线程,事件触发线程,定时器线程,网络请求线程等多个线程)
   (3) 解析URL(协议//主机:端口号/目录路径#查询参数#hash)
   (4) 解析协议 : 浏览器会根据解析出的协议，开辟一个网络线程，前往请求资源

二、开启网络线程到发出一个完整的http请求（这一部分涉及到dns查询，tcp/ip请求，五层因特网协议栈等知识）
   (1) 解析主机 : 如果输入主机的是域名，需要进行dns解析成IP
       1-1、如果浏览器有缓存，直接使用浏览器缓存，否则使用本机缓存，再没有的话就是用host
       1-2、如果本地没有，就向dns域名服务器查询，查询到对应的IP
   (2) 连接主机 : tcp/ip请求(三次握手建立连接发送请求,四次挥手断开连接)
       2-1、3次过程
            2-1-1、     
            2-1-2、     
            2-1-3、     
       2-2、4次过程
            2-2-1、
            2-2-2、
            2-2-3、
            2-2-4、

三、从服务器接收到请求后的处理（这一部分可能涉及到负载均衡，安全拦截以及后台内部的处理等等）
    (1) 负载均衡：对于大型的项目，由于并发访问量很大，所以往往一台服务器是吃不消的，所需要的处理方案称为负载均衡
    (2) 一般需要的处理步骤
        2-1、一般有的后端是有统一的验证的，如安全拦截，跨域验证
        2-2、如果这一步不符合规则，就直接返回了相应的http报文（如拒绝请求等）
        2-3、然后当验证通过后，才会进入实际的后台代码，此时是程序接收到请求，然后执行（譬如查询数据库，大量计算等等）
        2-4、等程序执行完毕后，就会返回一个http响应包（一般这一步也会经过多层封装）
        2-5、然后就是将这个包从后端发送到前端，完成交互

四、后台和前台的http交互（这一部分包括http头部、响应码、报文结构、cookie等知识，可以提下静态资源的cookie优化，以及编码解码，如gzip压缩等）
    (1) http报文(http报文作为信息的载体)
        1-1、通用头部(General)
             1-1-1、Request Url: 请求的web服务器地址
             1-1-1、Request Method: 请求方式（http:1.1 -> Get、POST、OPTIONS、PUT、HEAD、DELETE、CONNECT、TRACEd等）
             1-1-1、Status Code: 请求的返回状态码，如200代表成功
                    1xx——指示信息，表示请求已接收，继续处理
                    2xx——成功，表示请求已被成功接收、理解、接受
                    3xx——重定向，要完成请求必须进行更进一步的操作
                    4xx——客户端错误，请求有语法错误或请求无法实现
                    5xx——服务器端错误，服务器未能实现合法的请求

                    200——表明该请求被成功地完成，所请求的资源发送回客户端
                    304——自从上次请求后，请求的网页未修改过，请客户端使用本地缓存
                    400——客户端请求有错（譬如可以是安全模块拦截）
                    401——请求未经授权
                    403——禁止访问（譬如可以是未登录时禁止）
                    404——资源未找到
                    500——服务器内部错误
                    503——服务不可用
                    .....

             1-1-1、Remote Address: 请求的远程服务器地址

        1-2、请求头(Request headers)
            Accept: 接收类型，表示浏览器支持的MIME类型
            （对标服务端返回的Content-Type）
            Accept-Encoding：浏览器支持的压缩类型,如gzip等,超出类型不能接收
            Content-Type：客户端发送出去实体内容的类型
            Cache-Control: 指定请求和响应遵循的缓存机制，如no-cache
            If-Modified-Since：对应服务端的Last-Modified，用来匹配看文件是否变动，只能精确到1s之内，http1.0中
            Expires：缓存控制，在这个时间内不会请求，直接使用缓存，http1.0，而且是服务端时间
            Max-age：代表资源在本地缓存多少秒，有效时间内不会请求，而是使用缓存，http1.1中
            If-None-Match：对应服务端的ETag，用来匹配文件内容是否改变（非常精确），http1.1中
            Cookie: 有cookie并且同域访问时会自动带上
            Connection: 当浏览器与服务器通信时对于长连接如何进行处理,如keep-alive
            Host：请求的服务器URL
            Origin：最初的请求是从哪里发起的（只会精确到端口）,Origin比Referer更尊重隐私
            Referer：该页面的来源URL(适用于所有类型的请求，会精确到详细页面地址，csrf拦截常用到这个字段)
            User-Agent：用户客户端的一些必要信息，如UA头部等
        1-3、响应头(Response headers)
            Access-Control-Allow-Headers: 服务器端允许的请求Headers
            Access-Control-Allow-Methods: 服务器端允许的请求方法
            Access-Control-Allow-Origin: 服务器端允许的请求Origin头部（譬如为*）
            Content-Type：服务端返回的实体内容的类型
            Date：数据从服务器发送的时间
            Cache-Control：告诉浏览器或其他客户，什么环境可以安全的缓存文档
            Last-Modified：请求资源的最后修改时间
            Expires：应该在什么时候认为文档已经过期,从而不再缓存它
            Max-age：客户端的本地资源应该缓存多少秒，开启了Cache-Control后有效
            ETag：请求变量的实体标签的当前值
            Set-Cookie：设置和页面关联的cookie，服务器通过这个头部把cookie传给客户端
            Keep-Alive：如果客户端有keep-alive，服务端也会有响应（如timeout=38）
            Server：服务器的一些相关信息
        
        譬如，请求头部的Accept要和响应头部的Content-Type匹配，否则会报错
        譬如，跨域请求时，请求头部的Origin要匹配响应头部的Access-Control-Allow-Origin，否则会报跨域错误。。。
        1-4、请求/响应体
    (2) cookie 服务器向浏览器写入某些信息
    (3) gzip 压缩效率很好（高达70%左右）
    (4) 长连接与短连接
        4-1、长连接:一个tcp/ip连接上可以连续发送多个数据包，在tcp连接保持期间，如果没有数据包发送，需要双方发检测包以维持此连接，一般需要自己做在线维持（类似于心跳包）http1.1起，默认使用长连接，使用长连接会有这一行Connection: keep-alive
        
        4-2、短连接:通信双方有数据交互时，就建立一个tcp连接，数据发送完成后，则断开此tcp连接(http1.0默认短连接)
    (6) http 2.0
        6-1、http2.0不是https，它相当于是http的下一代规范
        6-2、然后简述下http2.0与http1.1的显著不同点：
             http1.1中，每请求一个资源，都是需要开启一个tcp/ip连接的，所以对应的结果是，每一个资源对应一个tcp/ip请求，由于tcp/ip本身有并发数限制，所以当资源一多，速度就显著慢下来
             http2.0中，一个tcp/ip请求可以请求多个资源，也就是说，只要一次tcp/ip请求，就可以请求若干个资源，分割成更小的帧请求，速度明显提升。
             所以，如果http2.0全面应用，很多http1.1中的优化方案就无需用到了（譬如打包成精灵图，静态资源多域名拆分等）

        6-3、然后简述下http2.0的一些特性：
            多路复用（即一个tcp/ip连接可以请求多个资源）
            首部压缩（http头部压缩，减少体积）
            二进制分帧（在应用层跟传送层之间增加了一个二进制分帧层，改进传输性能，实现低延迟和高吞吐量）
            服务器端推送（服务端可以对客户端的一个请求发出多个响应，可以主动通知客户端）
            请求优先级（如果流被赋予了优先级，它就会基于这个优先级来处理，由服务器决定需要多少资源来处理该请求。）
    5. 单独拎出来的缓存问题，http的缓存（这部分包括http缓存头部，etag，catch-control等）

6. 浏览器接收到http数据包后的解析流程（解析html-词法分析然后解析成dom树、解析css生成css规则树、合并成render树，然后layout、painting渲染、复合图层的合成、GPU绘制、外链资源的处理、loaded和domcontentloaded等）

7. CSS的可视化格式模型（元素的渲染规则，如包含块，控制框，BFC，IFC等概念）

8. JS引擎解析过程（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等）

9. 其它（可以拓展不同的知识模块，如跨域，web安全，hybrid模式等等内容）